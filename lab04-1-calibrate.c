#pragma config(Sensor, S1,     leftSensor,     sensorLightActive)
#pragma config(Sensor, S2,     rightSensor,    sensorLightActive)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int target = 0;

float kf = 0; //feed foreward constant, basically unused
float kp = 6;
float kd = 0;
float multiplier = 1.1; //use to make left side tilt corrector more powerful
int currentError = 0;
int pastError = 0;

int robot_calibrated = 0; //assigns values/allows balancing task to run


int feedForeward(int input){ //feed foreward box in diagram. input is 0 so it doesn't do anything in this case
	int output = input*kf;
	return output;
}

int control(int input){ //control portion of diagram, formula we're using is kp*angle+kd*angularVelocity
	int output = (int)(kp*(float)input);
	//nxtDisplayString(2,"%d",output);
	return output;
}
int plant(int input){ //plant section of diagram
	nxtDisplayString(7,"%d",input);
	motor[leftMotor] = input;
	motor[rightMotor] = input;
	float result = SensorValue[rightSensor] - SensorValue[leftSensor];
	//nxtDisplayString(0,"%f", result);
	return result;
}

task calibrate(){ 
	while(!robot_calibrated){
		//collect leftDown and rightUp, tilt robot so top of nxt tilted down
		if(nNxtButtonPressed == kLeftButton){ 
			target = SensorValue[rightSensor] - SensorValue[leftSensor];
			robot_calibrated = 1;
			nxtDisplayString(3,"%s", "Calibrated!");
		}	
	}
	//success
}	

task balance(){
	int output = 0;
	while(true){ //modeling the closed circuit pid (should be self explanitory, but just ask if you need)
		//int c = control(target+output);
		currentError = output - target; 
		int c = control(output - target);
		float damp = (kd*(currentError - pastError));
		nxtDisplayString(1,"%f", damp);
		int f = feedForeward(target);
		output = plant(f+c-damp);
		pastError = currentError;
		wait1Msec(5);
	}
}

task main()
{
	while(true){
		startTask(calibrate);
		while(!robot_calibrated) {}
		startTask(balance);
		while(true){};
	}	
}
