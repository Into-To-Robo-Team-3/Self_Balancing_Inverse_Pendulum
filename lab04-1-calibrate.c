#pragma config(Sensor, S1,     leftSensor,     sensorLightActive)
#pragma config(Sensor, S2,     rightSensor,    sensorLightActive)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
int target = 0;

float kf = 0; //feed foreward constant, basically unused
float kp = 10;
float kd = 10;
int damping = 5; // damping value assigned to variable in control()

float multiplier = 1.1; //use to make left side tilt corrector more powerful
int currentError = 1;
int pastError = 0;

int robot_calibrated = 0; //assigns values/allows balancing task to run


int feedForeward(int input){ //feed foreward box in diagram. input is 0 so it doesn't do anything in this case
	int output = input*kf;
	return output;
}

int control(int input){ //control portion of diagram, formula we're using is kp*angle+kd*angularVelocity
	int output = (int)(kp*(float)input);
	nxtDisplayString(2,"%d",output);
	return output;
}
int plant(int input){ //plant section of diagram
	nxtDisplayString(7,"%d",input);
	motor[leftMotor] = input;
	motor[rightMotor] = input;
	float result = SensorValue[rightSensor] - SensorValue[leftSensor];
	nxtDisplayString(0,"%f", result);
	return result;
}

task calibrate(){ 
	while(!robot_calibrated){
		//collect leftDown and rightUp, tilt robot so top of nxt tilted down
		if(nNxtButtonPressed == kLeftButton){ 
			target = SensorValue[rightSensor] - SensorValue[leftSensor];
			robot_calibrated = 1;
			nxtDisplayString(0,"%s", "Calibrated!");
			nxtDisplayString(1,"%d", target);
		}	
	}
	//success
}	

task balance(){
	int output = 0;
	while(true){ //modeling the closed circuit pid (should be self explanitory, but just ask if you need)
		//int c = control(target+output);
		currentError = SensorValue[rightSensor] - SensorValue[leftSensor] - target; 
		int c = control(output - target);
		int damp = kd*(currentError - pastError);
		int f = feedForeward(target);
		output = plant(f+c-damp);
		pastError = currentError;
	}
}

task main()
{
	while(true){
		int left0 = SensorValue[leftSensor]; //for testing purposes only
		int right0 = SensorValue[rightSensor];
		nxtDisplayString(2,"%d",left0);
		nxtDisplayString(3,"%d",right0);//end for testing purposes only
		startTask(calibrate);
		while(!robot_calibrated) {}
		startTask(balance);
		while(true){};
	}	
}
