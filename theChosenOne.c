#pragma config(Sensor, S1,     leftSensor,     sensorLightActive)
#pragma config(Sensor, S4,     rightSensor,    sensorLightActive)
#pragma config(Motor,  motorA,          leftMotor,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int target = 1;

int kf = 0; //feed foreward constant, basically unused
int kp = 3;
int kd = 6;
int ki = 25;
//int damping = 5; // damping value assigned to variable in control()

//float multiplier = 1.1; //use to make left side tilt corrector more powerful
int currentError = 0;
int pastError = 0;

int totalError = 0;

int robot_calibrated = 0; //assigns values/allows balancing task to run


int feedForeward(int input){ //feed foreward box in diagram. input is 0 so it doesn't do anything in this case
	int output = input*(int)kf;
	return output;
}

int control(int input, int damp, int integral){ //control portion of diagram, formula we're using is kp*angle+kd*angularVelocity
	int output = (int)(kp*input-damp+integral);
	nxtDisplayString(2,"%d",output);
	return output;
}
int plant(int input){ //plant section of diagram
	nxtDisplayString(7,"%d",input);
	motor[leftMotor] = input;
	motor[rightMotor] = input;
	int result = SensorValue[rightSensor] - SensorValue[leftSensor];
	nxtDisplayString(0,"%d", result);
	return result;
}

task calibrate(){ 
	while(!robot_calibrated){
		//collect leftDown and rightUp, tilt robot so top of nxt tilted down
		if(nNxtButtonPressed == kLeftButton){ 
			target = SensorValue[rightSensor] - SensorValue[leftSensor];
			nxtDisplayString(4,"left:%d",SensorValue[leftSensor]);
			nxtDisplayString(5,"left:%d",SensorValue[rightSensor]);
			robot_calibrated = 1;
			nxtDisplayString(0,"%s", "Calibrated!");
			nxtDisplayString(1,"%d", target);
		}	
	}
	//success
}	

task balance(){
	int output = 0;
	int t = 0;
	while(true){ //modeling the closed circuit pid (should be self explanitory, but just ask if you need)
		//int c = control(target+output);
		if(t==2){
			pastError = currentError;	
			currentError = SensorValue[rightSensor] - SensorValue[leftSensor] - target; 
			totalError += currentError;
		nxtDisplayClearTextLine(6);
		nxtDisplayClearTextLine(7)
		nxtDisplayString(6,"dampening: %d", totalError/ki);
			t=0;
		}
		t++;
		wait1Msec(1);
		int damp = kd*(currentError - pastError);
		int integral = totalError/ki;
		int c = control(output - target,damp,integral);
		int f = feedForeward(target);
		output = plant(f+c);
	}
}

task main()
{
	while(true){
		int left0 = SensorValue[leftSensor]; //for testing purposes only
		int right0 = SensorValue[rightSensor];
		nxtDisplayString(2,"%d",left0);
		nxtDisplayString(3,"%d",right0);//end for testing purposes only
		//startTask(calibrate);
		//while(!robot_calibrated) {}
		startTask(balance);
		while(true){};
	}	
}
