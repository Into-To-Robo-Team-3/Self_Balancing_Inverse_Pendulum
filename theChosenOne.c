
#pragma config(Motor,  motorA,          leftMotor,    tmotorNXT, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorB,          rightMotor,     tmotorNXT, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define POWER 50
int velocityUpdateInterval = 5;
int PIDUpdateInterval = 2;

int motorPower = POWER;
// Controls
int target = 0;
float kp = 5;
float ki = 250;
float kd = 4;
//float kf = 1;
int totalError = 0;
//float multiplier = 1; // motor power difference compensator 

//Robot Attributes
float od=2.25;     //Wheel diameter
//float dwb=4.25; //wheel base diameter
float cir=od*PI; //Wheel goalStraightumference
float ticksperin=360/cir;  //ticks per inch
int robot_ready = 1;



int control(int input, float damp, float integral){ //control portion of diagram, formula we're using is kp*angle+kd*angularVelocity
	int output = (int)((int)(kp*(float)input-damp+integral));
	return output;
}
int plant(int power, int input){ //plant section of diagram
	int leftOffset = 0;
	int rightOffset = 0;
	if(input < motorPower) //left motor slacking
		leftOffset = -input;
	else if(input > motorPower) //right motor slacking 
		rightOffset = -input;
	motor[leftMotor] = power + leftOffset;
	motor[rightMotor] = power + rightOffset;
	int result = nMotorEncoder(leftMotor) - nMotorEncoder(rightMotor);
	nxtDisplayString(5,"L_power: %d", power + leftOffset);
	nxtDisplayString(6,"R_power: %d", power + rightOffset);
	return result;
}


int straight(float input) //input = distance in inches
{
	robot_ready = 0;
	//reset encoders
	nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	//set up motor PID 
	nMotorPIDSpeedCtrl[leftMotor] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[rightMotor] = mtrSpeedReg;
	nPidUpdateInterval = PIDUpdateInterval;
	
  float ticks=input*ticksperin; //total ticks
  float ramp_slope = 0.001; //acceleration rate
  float ramp = 0; //start from standstill
  float scale = 1.01; //travel distance compensator 
  int pastError = 0;
  int currentError = 0;
  int output = 0; //for plant()
  int power = 0; //power to be assigned to motor
  //loop through encoder ticks
  while(nMotorEncoder(leftMotor)+nMotorEncoder(rightMotor) <(int)(2*ticks*scale)){
  	if(ramp < 1) //accelerate
   			ramp = ramp + ramp_slope;
   	power = motorPower*ramp;
   	pastError = currentError;
 		currentError = nMotorEncoder(leftMotor) - nMotorEncoder(rightMotor);
 		totalError = totalError + currentError; //for integral term
 		float damp = kd*(float)(currentError - pastError); //damper
 		float integral = (float)totalError/ki; //integral
 		int c = control(output - target,damp,integral); 
		//nxtDisplayString(0,"Input: %d",c);
		//nxtDisplayString(1,"Output:%d", output);
		//nxtDisplayString(2,"Error: %d", currentError);
		output = plant(power, c);
 	}
 	//stop 
 	motor[leftMotor]=0;
  motor[rightMotor]=0;
  //reset encoders
  nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
  //nxtDisplayString(3,"L_Motor: %d", nMotorEncoder[leftMotor]);
  //nxtDisplayString(4,"R_Motor: %d", nMotorEncoder[rightMotor]);
  //nxtDisplayString(5,"totalError: %d", totalError);
  robot_ready = 1;
  return 0;
}

int turn(float goalTurn){
	//nxtDisplayString(7,"YEERRRR");
	robot_ready = 0;
	float turn_pwr=30;
	float od=2.25;     //Wheel diameter
	float turnAng=goalTurn; //angle to turn
	float dwb=4.25; //wheel base diameter
	float wheelAng=((dwb*turnAng)/od);//Angle we want the wheel to turn
	float t_ramp_slope = 0.0001;
  float turn_ramp = 0;
  float turn_scale= 0.945;
  //Turn left (positive) or right (negative)
	while(nMotorEncoder(leftMotor) < (int)(wheelAng*turn_scale)||(wheelAng<0&&nMotorEncoder(leftMotor)>(int)(wheelAng*turn_scale))){
		//turn_ramp = 1;
		if(wheelAng>0){
			if(turn_ramp < 1) //Gradually bring the robot to turning speed to minimize slip
 				turn_ramp = turn_ramp + t_ramp_slope;
 			motor[leftMotor]=(int)(turn_pwr*turn_ramp);
 			motor[rightMotor]=-(int)(turn_pwr*turn_ramp);
 		}
 		else{//
 			if(turn_ramp < 1)
 				turn_ramp = turn_ramp + t_ramp_slope;
 			motor[leftMotor]=-(int)(turn_pwr*turn_ramp);
 			motor[rightMotor]=(int)(turn_pwr*turn_ramp);
 		}
  }
  //stop 
  motor[rightMotor] = 0;
  motor[leftMotor] = 0;
  //reset encoders
  nMotorEncoder[leftMotor] = 0;
	nMotorEncoder[rightMotor] = 0;
	robot_ready = 1;
	return 0;
}

task locomotion()
{
	//int distance = 12;
	//straight(distance);
	//wait1Msec(200);
	//nxtDisplayString(7,"TUUUUURNNN");
	//int robot_ready = 1;
  int result = 0;
	int x1 = 20;
	int y1 = 6;
	int x2 = 20;
	int y2 = 40;
	float directions[4][2] = {
		{6.75, 0},
		{8.38825, 45},
		{8.25, 90},
		{4.596189, 45}
	};
	int length = 4;
	for(int index = 0; index<length; index++){
		result = turn(directions[index][1]);
		//while(!robot_ready){}
		wait1Msec(1000);
		result = straight(directions[index][0]);
		//while(!robot_ready){}
		wait1Msec(1000);
		nxtDisplayString(0,"dist: %f", directions[index][0]);
		nxtDisplayString(1,"angle: %f", directions[index][1]);
	}	
}	

task main()
{
	startTask(locomotion);
	while(nNxtButtonPressed != kExitButton) {}
}
